<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Odds Comparison App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }

        .glassmorphic {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .neumorphic-button {
            background: #f0f2f5;
            box-shadow: 6px 6px 12px #c5c7ca, -6px -6px 12px #ffffff;
            transition: all 0.2s ease-in-out;
        }

        .neumorphic-button:hover {
            box-shadow: 4px 4px 8px #c5c7ca, -4px -4px 8px #ffffff;
        }

        .neumorphic-button:active {
            box-shadow: inset 4px 4px 8px #c5c7ca, inset -4px -4px 8px #ffffff;
        }

        .loader {
            border-top-color: #007aff;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="none" stroke="%236b7280" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l4 4 4-4"/></svg>');
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1em;
        }

        .odds-cell {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative;
        }

        .odds-cell:hover {
            background-color: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .odds-cell.selected {
            background-color: rgba(34, 197, 94, 0.2);
            border: 2px solid #22c55e;
        }

        .odds-cell.best-odds {
            background-color: rgba(251, 191, 36, 0.15);
            font-weight: 600;
        }

        .odds-cell.selected.best-odds {
            background-color: rgba(34, 197, 94, 0.3);
        }

        .checkmark {
            position: absolute;
            top: 2px;
            right: 2px;
            color: #22c55e;
            font-weight: bold;
        }

        .player-row {
            transition: all 0.3s ease;
        }

        .player-row.expanded {
            background-color: rgba(243, 244, 246, 0.5);
        }

        .expand-icon {
            transition: transform 0.3s ease;
        }

        .expand-icon.rotated {
            transform: rotate(90deg);
        }

        .selection-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        @media (min-width: 768px) {
            .selection-panel {
                bottom: 20px;
                left: auto;
                right: 20px;
                width: 450px;
                max-height: 500px;
                border-radius: 1rem;
            }
        }

        .odds-table {
            font-size: 0.875rem;
        }

        .odds-value {
            font-weight: 500;
            color: #1f2937;
        }

        .line-value {
            font-weight: 600;
            color: #4b5563;
        }

        .market-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
    </style>
</head>
<body class="text-gray-800">

    <div id="api-usage-tracker" class="hidden fixed top-4 right-4 z-50 text-white py-2 px-4 rounded-lg shadow-lg text-sm font-medium">
        API Requests Remaining: <span id="api-requests-remaining">N/A</span>
    </div>

    <div class="container mx-auto p-4 md:p-8" style="padding-bottom: 350px;">

        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900 mb-2">NBA Odds Comparison</h1>
            <p class="text-gray-600">Compare odds across all bookmakers and build your custom CSV</p>
        </header>

        <main>
            <div id="main-content" class="glassmorphic rounded-2xl shadow-lg p-6 md:p-8">

                <div id="fetch-section" class="text-center">
                    <button id="fetchEventsButton" class="neumorphic-button text-gray-800 font-bold py-3 px-8 rounded-full transition duration-300">
                        Fetch Upcoming Games
                    </button>
                </div>

                <div id="game-selection-area" class="hidden space-y-6">
                    <div>
                        <label for="eventsDropdown" class="block text-sm font-medium text-gray-700 mb-2">Select a Game</label>
                        <select id="eventsDropdown" class="w-full p-3 bg-white bg-opacity-80 border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </select>
                    </div>

                    <div id="odds-comparison-container" class="hidden space-y-4">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold text-gray-900">üìä Odds Comparison</h2>
                            <div class="text-sm text-gray-600">
                                Click on any odds to add to CSV
                            </div>
                        </div>

                        <!-- Bookmaker Filter -->
                        <div id="bookmaker-filter-container" class="hidden glassmorphic rounded-xl p-4 mb-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-sm font-semibold text-gray-700">üîç Filter by Bookmakers</h3>
                                <div class="space-x-2">
                                    <button id="selectAllBookmakers" class="text-xs px-3 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                                        Select All
                                    </button>
                                    <button id="deselectAllBookmakers" class="text-xs px-3 py-1 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                                        Deselect All
                                    </button>
                                </div>
                            </div>
                            <div id="bookmaker-checkboxes" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                <!-- Bookmaker checkboxes will be populated here -->
                            </div>
                        </div>

                        <div id="odds-comparison-content"></div>
                    </div>
                </div>
            </div>

            <div id="loader" class="hidden justify-center items-center mt-8">
                <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-32 w-32"></div>
            </div>

            <div id="error" class="hidden mt-8 text-center bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-xl relative" role="alert">
                <strong class="font-bold">Error!</strong>
                <span class="block sm:inline" id="errorMessage"></span>
            </div>

            <div id="usage-info-container" class="hidden mt-4 text-center text-sm text-gray-600">
                <p>API Key Usage (Last Request): <span id="usage-info-details" class="font-medium"></span></p>
            </div>

        </main>
    </div>

    <!-- Selection Panel -->
    <div id="selection-panel" class="selection-panel hidden glassmorphic">
        <div class="p-4">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-bold text-gray-900">
                    üìã Selected Lines (<span id="selection-count">0</span>)
                </h3>
                <div class="space-x-2">
                    <button id="clearSelectionsBtn" class="text-sm px-3 py-1 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                        Clear All
                    </button>
                    <button id="exportSelectionsBtn" class="text-sm px-3 py-1 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors">
                        Export CSV
                    </button>
                </div>
            </div>
            <div id="selected-lines-list" class="space-y-2 max-h-96 overflow-y-auto">
                <!-- Selected lines will appear here -->
            </div>
        </div>
    </div>

    <!-- CSV Team Selection Modal -->
    <div id="csvTeamModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="glassmorphic rounded-2xl shadow-xl w-full max-w-md">
            <div class="p-6">
                <h3 class="text-xl font-semibold text-gray-900 text-center mb-4">Select Team for CSV Export</h3>
                <p class="text-sm text-gray-600 mb-4 text-center">This will be used as the LEAGUE_NAME in your CSV file</p>
                <select id="csvTeamSelect" class="w-full p-3 bg-white bg-opacity-80 border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 mb-6">
                    <option value="">-- Select Team --</option>
                </select>
                <div class="flex space-x-3">
                    <button id="cancelCsvExportBtn" class="flex-1 py-3 px-4 bg-gray-500 text-white font-medium rounded-xl hover:bg-gray-600 transition-colors">
                        Cancel
                    </button>
                    <button id="confirmCsvExportBtn" class="flex-1 py-3 px-4 bg-green-600 text-white font-medium rounded-xl hover:bg-green-700 transition-colors">
                        Export
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const sport = 'basketball_nba';
        const regions = 'us,eu';
        const oddsFormat = 'decimal';

        const marketsMap = {
            'player_points': 'Points',
            'player_rebounds': 'Rebounds',
            'player_assists': 'Assists',
            'player_threes': '3-Pointers Made',
            'player_blocks': 'Blocks',
            'player_points_rebounds_assists': 'Points+Rebounds+Assists'
        };
        const markets = Object.keys(marketsMap).join(',');

        // DOM Elements
        const fetchEventsButton = document.getElementById('fetchEventsButton');
        const gameSelectionArea = document.getElementById('game-selection-area');
        const eventsDropdown = document.getElementById('eventsDropdown');
        const oddsComparisonContainer = document.getElementById('odds-comparison-container');
        const oddsComparisonContent = document.getElementById('odds-comparison-content');
        const bookmakerFilterContainer = document.getElementById('bookmaker-filter-container');
        const bookmakerCheckboxes = document.getElementById('bookmaker-checkboxes');
        const selectAllBookmakers = document.getElementById('selectAllBookmakers');
        const deselectAllBookmakers = document.getElementById('deselectAllBookmakers');
        const loader = document.getElementById('loader');
        const errorDiv = document.getElementById('error');
        const errorMessage = document.getElementById('errorMessage');
        const selectionPanel = document.getElementById('selection-panel');
        const selectedLinesList = document.getElementById('selected-lines-list');
        const selectionCount = document.getElementById('selection-count');
        const clearSelectionsBtn = document.getElementById('clearSelectionsBtn');
        const exportSelectionsBtn = document.getElementById('exportSelectionsBtn');
        const csvTeamModal = document.getElementById('csvTeamModal');
        const csvTeamSelect = document.getElementById('csvTeamSelect');
        const cancelCsvExportBtn = document.getElementById('cancelCsvExportBtn');
        const confirmCsvExportBtn = document.getElementById('confirmCsvExportBtn');

        // State variables
        let fetchedEvents = [];
        let selectedBookmakers = new Set(); // Track selected bookmakers for filtering
        let currentFullGameData = null;
        let currentEventCommenceTime = null;
        let currentHomeTeam = null;
        let currentAwayTeam = null;
        let nbaPlayersData = [];
        let selectedLines = []; // Array of {id, player, market, bookmaker, line, outcome, price, team}
        let expandedPlayers = new Set(); // Track which players are expanded

        function displayUsageInfo(usageInfo) {
            const usageContainer = document.getElementById('usage-info-container');
            const usageDetails = document.getElementById('usage-info-details');
            if (usageInfo && (usageInfo.remaining || usageInfo.used)) {
                usageDetails.textContent = `Key: ${usageInfo.keyUsed} | Remaining: ${usageInfo.remaining || 'N/A'} | Used: ${usageInfo.used || 'N/A'}`;
                usageContainer.classList.remove('hidden');
            }

            const usageTracker = document.getElementById('api-usage-tracker');
            const remainingSpan = document.getElementById('api-requests-remaining');

            if (usageInfo && usageInfo.remaining) {
                const remaining = parseInt(usageInfo.remaining, 10);
                remainingSpan.textContent = remaining;

                if (remaining < 50) {
                    usageTracker.classList.add('bg-red-600');
                    usageTracker.classList.remove('bg-blue-600', 'bg-gray-500');
                } else {
                    usageTracker.classList.add('bg-blue-600');
                    usageTracker.classList.remove('bg-red-600', 'bg-gray-500');
                }

                usageTracker.classList.remove('hidden');
            } else if (usageInfo) {
                remainingSpan.textContent = 'N/A';
                usageTracker.classList.add('bg-gray-500');
                usageTracker.classList.remove('bg-red-600', 'bg-blue-600');
                usageTracker.classList.remove('hidden');
            }
        }

        async function loadNbaPlayersData() {
            try {
                const response = await fetch('./nba_players.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                nbaPlayersData = await response.json();
            } catch (error) {
                console.error("Failed to load NBA players data:", error);
                errorMessage.textContent = "Failed to load nba_players.json. Check if file exists.";
                errorDiv.classList.remove('hidden');
            }
        }

        function findPlayerTeam(playerName) {
            const player = nbaPlayersData.find(p => p.name === playerName);
            return player ? player.team : 'N/A';
        }

        document.addEventListener('DOMContentLoaded', loadNbaPlayersData);

        fetchEventsButton.addEventListener('click', async () => {
            gameSelectionArea.classList.add('hidden');
            oddsComparisonContainer.classList.add('hidden');
            errorDiv.classList.add('hidden');
            loader.classList.remove('hidden');
            loader.classList.add('flex');
            fetchEventsButton.disabled = true;
            fetchEventsButton.classList.add('opacity-50', 'cursor-not-allowed');

            try {
                const cachedEvents = sessionStorage.getItem('nbaEvents');
                if (cachedEvents) {
                    fetchedEvents = JSON.parse(cachedEvents);
                    const lastUsage = sessionStorage.getItem('lastApiUsage');
                    if(lastUsage) {
                        displayUsageInfo(JSON.parse(lastUsage));
                    }
                } else {
                    const eventsUrl = `/.netlify/functions/get-events?sport=${sport}`;
                    const eventsResponse = await fetch(eventsUrl);
                    if (!eventsResponse.ok) {
                        const errorData = await eventsResponse.json();
                        throw new Error(`Failed to fetch events: ${errorData.message || eventsResponse.statusText}`);
                    }

                    const responseBody = await eventsResponse.json();
                    fetchedEvents = responseBody.data;

                    if (responseBody.usageInfo) {
                        displayUsageInfo(responseBody.usageInfo);
                        sessionStorage.setItem('lastApiUsage', JSON.stringify(responseBody.usageInfo));
                    }

                    sessionStorage.setItem('nbaEvents', JSON.stringify(fetchedEvents));
                }

                if (fetchedEvents.length === 0) {
                     gameSelectionArea.classList.remove('hidden');
                     eventsDropdown.innerHTML = '<option value="">No upcoming NBA events found.</option>';
                } else {
                    populateEventsDropdown(fetchedEvents);
                    gameSelectionArea.classList.remove('hidden');
                }
                document.getElementById('fetch-section').classList.add('hidden');

            } catch (error) {
                console.error('An error occurred:', error);
                errorMessage.textContent = error.message;
                errorDiv.classList.remove('hidden');
            } finally {
                loader.classList.add('hidden');
                loader.classList.remove('flex');
                fetchEventsButton.disabled = false;
                fetchEventsButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });

        function populateEventsDropdown(events) {
            eventsDropdown.innerHTML = '<option value="">-- Please select a match --</option>';
            events.forEach(event => {
                const option = document.createElement('option');
                option.value = event.id;
                option.dataset.homeTeam = event.home_team;
                option.dataset.awayTeam = event.away_team;
                const commenceTime = new Date(event.commence_time).toLocaleString();
                option.textContent = `${event.home_team} vs ${event.away_team} (${commenceTime})`;
                eventsDropdown.appendChild(option);
            });
        }

        eventsDropdown.addEventListener('change', async (e) => {
            const selectedOption = e.target.options[e.target.selectedIndex];
            const eventId = selectedOption.value;
            currentHomeTeam = selectedOption.dataset.homeTeam;
            currentAwayTeam = selectedOption.dataset.awayTeam;
            const selectedEvent = fetchedEvents.find(event => event.id === eventId);
            currentEventCommenceTime = selectedEvent ? selectedEvent.commence_time : null;

            oddsComparisonContent.innerHTML = '';
            oddsComparisonContainer.classList.add('hidden');
            bookmakerFilterContainer.classList.add('hidden');
            currentFullGameData = null;
            selectedLines = [];
            expandedPlayers.clear();
            selectedBookmakers.clear(); // Reset bookmaker filter
            updateSelectionPanel();

            if (!eventId) return;

            oddsComparisonContainer.classList.remove('hidden');
            const miniLoaderHTML = '<div class="flex justify-center p-8"><div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12"></div></div>';
            oddsComparisonContent.innerHTML = miniLoaderHTML;

            try {
                const cacheKey = `nbaOdds_${eventId}`;
                const cachedOdds = sessionStorage.getItem(cacheKey);

                if (cachedOdds) {
                    currentFullGameData = JSON.parse(cachedOdds);
                    const lastUsage = sessionStorage.getItem('lastApiUsage');
                    if(lastUsage) {
                        displayUsageInfo(JSON.parse(lastUsage));
                    }
                } else {
                    const oddsUrl = `/.netlify/functions/get-odds?sport=${sport}&eventId=${eventId}&regions=${regions}&markets=${markets}&oddsFormat=${oddsFormat}`;
                    const res = await fetch(oddsUrl);

                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(errorData.message || `HTTP error ${res.status}`);
                    }

                    const responseBody = await res.json();
                    currentFullGameData = responseBody.data;

                    if (responseBody.usageInfo) {
                        displayUsageInfo(responseBody.usageInfo);
                        sessionStorage.setItem('lastApiUsage', JSON.stringify(responseBody.usageInfo));
                    }

                    sessionStorage.setItem(cacheKey, JSON.stringify(currentFullGameData));
                }

                populateBookmakerFilter();
                renderOddsComparison();

            } catch (error) {
                const errorHTML = `<p class="text-red-500 text-center">Could not fetch player odds: ${error.message}</p>`;
                oddsComparisonContent.innerHTML = errorHTML;
            }
        });

        function populateBookmakerFilter() {
            if (!currentFullGameData || !currentFullGameData.bookmakers) return;

            // Get all unique bookmakers
            const bookmakers = currentFullGameData.bookmakers.map(b => ({
                key: b.key,
                title: b.title
            }));

            // Initialize all as selected if none are selected yet
            if (selectedBookmakers.size === 0) {
                bookmakers.forEach(b => selectedBookmakers.add(b.key));
            }

            // Populate checkboxes
            bookmakerCheckboxes.innerHTML = bookmakers.map(bookie => `
                <label class="flex items-center space-x-2 p-2 bg-white bg-opacity-60 rounded-lg cursor-pointer hover:bg-opacity-80 transition-all">
                    <input
                        type="checkbox"
                        class="bookmaker-checkbox w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500"
                        value="${bookie.key}"
                        ${selectedBookmakers.has(bookie.key) ? 'checked' : ''}
                        onchange="toggleBookmakerFilter('${bookie.key}')"
                    >
                    <span class="text-sm text-gray-700">${bookie.title}</span>
                </label>
            `).join('');

            bookmakerFilterContainer.classList.remove('hidden');
        }

        function toggleBookmakerFilter(bookmakerKey) {
            if (selectedBookmakers.has(bookmakerKey)) {
                selectedBookmakers.delete(bookmakerKey);
            } else {
                selectedBookmakers.add(bookmakerKey);
            }
            renderOddsComparison();
        }

        selectAllBookmakers.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.bookmaker-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
                selectedBookmakers.add(cb.value);
            });
            renderOddsComparison();
        });

        deselectAllBookmakers.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.bookmaker-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
                selectedBookmakers.delete(cb.value);
            });
            renderOddsComparison();
        });

        function renderOddsComparison() {
            oddsComparisonContent.innerHTML = '';

            if (!currentFullGameData || !currentFullGameData.bookmakers || currentFullGameData.bookmakers.length === 0) {
                oddsComparisonContent.innerHTML = '<p class="text-center text-gray-500">No odds available for this game.</p>';
                return;
            }

            // Filter bookmakers based on selected filters
            const bookmakers = currentFullGameData.bookmakers.filter(b =>
                selectedBookmakers.size === 0 || selectedBookmakers.has(b.key)
            );

            // Show message if no bookmakers selected
            if (bookmakers.length === 0) {
                oddsComparisonContent.innerHTML = '<p class="text-center text-gray-500">No bookmakers selected. Please select at least one bookmaker from the filter above.</p>';
                return;
            }

            // Organize data by market -> player -> bookmaker -> outcomes
            const marketData = {};

            bookmakers.forEach(bookie => {
                bookie.markets.forEach(market => {
                    if (!marketData[market.key]) {
                        marketData[market.key] = {};
                    }

                    market.outcomes.forEach(outcome => {
                        const playerName = outcome.description;

                        if (!marketData[market.key][playerName]) {
                            marketData[market.key][playerName] = {};
                        }

                        if (!marketData[market.key][playerName][bookie.key]) {
                            marketData[market.key][playerName][bookie.key] = {
                                title: bookie.title,
                                outcomes: []
                            };
                        }

                        marketData[market.key][playerName][bookie.key].outcomes.push(outcome);
                    });
                });
            });

            // Render each market
            for (const marketKey in marketData) {
                const marketName = marketsMap[marketKey] || marketKey;
                const players = Object.keys(marketData[marketKey]).sort();

                let marketHTML = `
                    <div class="glassmorphic rounded-xl overflow-hidden mb-4">
                        <div class="market-header px-6 py-4">
                            <h3 class="text-xl font-bold">${marketName}</h3>
                        </div>
                        <div class="p-4">
                `;

                players.forEach(playerName => {
                    const team = findPlayerTeam(playerName);
                    const isExpanded = expandedPlayers.has(playerName);
                    const playerId = `player-${marketKey}-${playerName.replace(/\s+/g, '-')}`;

                    marketHTML += `
                        <div class="player-row mb-3 ${isExpanded ? 'expanded' : ''}">
                            <div class="flex items-center justify-between p-3 bg-white bg-opacity-60 rounded-lg cursor-pointer hover:bg-opacity-80 transition-all" onclick="togglePlayer('${playerName}')">
                                <div class="flex items-center space-x-3">
                                    <span class="expand-icon ${isExpanded ? 'rotated' : ''} text-gray-600 font-bold">‚ñ∂</span>
                                    <div>
                                        <span class="font-semibold text-gray-900">${playerName}</span>
                                        <span class="ml-2 text-xs text-gray-500">(${team})</span>
                                    </div>
                                </div>
                                <button onclick="event.stopPropagation(); addAllPlayerLines('${playerName}', '${marketKey}')" class="text-xs px-3 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                                    Add All
                                </button>
                            </div>

                            <div id="${playerId}" class="${isExpanded ? '' : 'hidden'} mt-2 ml-8">
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
                    `;

                    const bookmakersForPlayer = marketData[marketKey][playerName];

                    for (const bookieKey in bookmakersForPlayer) {
                        const bookieData = bookmakersForPlayer[bookieKey];
                        const outcomes = bookieData.outcomes;

                        // Check if Over/Under or Yes/No market
                        const isOverUnder = outcomes.some(o => o.name === 'Over' || o.name === 'Under');

                        if (isOverUnder) {
                            const over = outcomes.find(o => o.name === 'Over');
                            const under = outcomes.find(o => o.name === 'Under');
                            const line = over?.point || under?.point || 'N/A';

                            // Find best odds for this line
                            const bestOverOdds = findBestOdds(marketKey, playerName, line, 'Over');
                            const bestUnderOdds = findBestOdds(marketKey, playerName, line, 'Under');

                            if (over) {
                                const lineId = `${playerName}|${marketKey}|${bookieKey}|${line}|Over`;
                                const isSelected = selectedLines.some(l => l.id === lineId);
                                const isBest = over.price === bestOverOdds;

                                marketHTML += `
                                    <div class="odds-cell ${isSelected ? 'selected' : ''} ${isBest ? 'best-odds' : ''} p-3 bg-white rounded-lg border border-gray-200" onclick="toggleLineSelection('${lineId}', '${playerName}', '${marketName}', '${bookieData.title}', '${line}', 'Over', ${over.price}, '${team}')">
                                        ${isSelected ? '<span class="checkmark">‚úì</span>' : ''}
                                        <div class="text-xs text-gray-600 mb-1">${bookieData.title}</div>
                                        <div class="font-semibold text-sm text-gray-900">Over <span class="line-value">${line}</span></div>
                                        <div class="odds-value text-lg mt-1">${over.price}</div>
                                        ${isBest ? '<div class="text-xs text-amber-600 mt-1">‚òÖ Best</div>' : ''}
                                    </div>
                                `;
                            }

                            if (under) {
                                const lineId = `${playerName}|${marketKey}|${bookieKey}|${line}|Under`;
                                const isSelected = selectedLines.some(l => l.id === lineId);
                                const isBest = under.price === bestUnderOdds;

                                marketHTML += `
                                    <div class="odds-cell ${isSelected ? 'selected' : ''} ${isBest ? 'best-odds' : ''} p-3 bg-white rounded-lg border border-gray-200" onclick="toggleLineSelection('${lineId}', '${playerName}', '${marketName}', '${bookieData.title}', '${line}', 'Under', ${under.price}, '${team}')">
                                        ${isSelected ? '<span class="checkmark">‚úì</span>' : ''}
                                        <div class="text-xs text-gray-600 mb-1">${bookieData.title}</div>
                                        <div class="font-semibold text-sm text-gray-900">Under <span class="line-value">${line}</span></div>
                                        <div class="odds-value text-lg mt-1">${under.price}</div>
                                        ${isBest ? '<div class="text-xs text-amber-600 mt-1">‚òÖ Best</div>' : ''}
                                    </div>
                                `;
                            }
                        } else {
                            // Yes/No market
                            outcomes.forEach(outcome => {
                                const lineId = `${playerName}|${marketKey}|${bookieKey}|N/A|${outcome.name}`;
                                const isSelected = selectedLines.some(l => l.id === lineId);
                                const bestOdds = findBestOdds(marketKey, playerName, 'N/A', outcome.name);
                                const isBest = outcome.price === bestOdds;

                                marketHTML += `
                                    <div class="odds-cell ${isSelected ? 'selected' : ''} ${isBest ? 'best-odds' : ''} p-3 bg-white rounded-lg border border-gray-200" onclick="toggleLineSelection('${lineId}', '${playerName}', '${marketName}', '${bookieData.title}', 'N/A', '${outcome.name}', ${outcome.price}, '${team}')">
                                        ${isSelected ? '<span class="checkmark">‚úì</span>' : ''}
                                        <div class="text-xs text-gray-600 mb-1">${bookieData.title}</div>
                                        <div class="font-semibold text-sm text-gray-900">${outcome.name}</div>
                                        <div class="odds-value text-lg mt-1">${outcome.price}</div>
                                        ${isBest ? '<div class="text-xs text-amber-600 mt-1">‚òÖ Best</div>' : ''}
                                    </div>
                                `;
                            });
                        }
                    }

                    marketHTML += `
                                </div>
                            </div>
                        </div>
                    `;
                });

                marketHTML += `
                        </div>
                    </div>
                `;

                oddsComparisonContent.innerHTML += marketHTML;
            }
        }

        function findBestOdds(marketKey, playerName, line, outcome) {
            // Filter bookmakers based on selected filters
            const bookmakers = currentFullGameData.bookmakers.filter(b =>
                selectedBookmakers.size === 0 || selectedBookmakers.has(b.key)
            );
            let bestOdds = 0;

            bookmakers.forEach(bookie => {
                const market = bookie.markets.find(m => m.key === marketKey);
                if (market) {
                    market.outcomes.forEach(o => {
                        if (o.description === playerName && o.name === outcome) {
                            if (line === 'N/A' || o.point === parseFloat(line)) {
                                if (o.price > bestOdds) {
                                    bestOdds = o.price;
                                }
                            }
                        }
                    });
                }
            });

            return bestOdds;
        }

        function togglePlayer(playerName) {
            if (expandedPlayers.has(playerName)) {
                expandedPlayers.delete(playerName);
            } else {
                expandedPlayers.add(playerName);
            }
            renderOddsComparison();
        }

        function toggleLineSelection(lineId, player, market, bookmaker, line, outcome, price, team) {
            const existingIndex = selectedLines.findIndex(l => l.id === lineId);

            if (existingIndex > -1) {
                // Deselecting - remove this line and its pair if it's Over/Under
                selectedLines.splice(existingIndex, 1);

                // If this was Over/Under, also remove the matching opposite side
                if (outcome === 'Over' || outcome === 'Under') {
                    const oppositeOutcome = outcome === 'Over' ? 'Under' : 'Over';
                    const oppositeIndex = selectedLines.findIndex(l =>
                        l.player === player &&
                        l.market === market &&
                        l.bookmaker === bookmaker &&
                        l.line === line &&
                        l.outcome === oppositeOutcome
                    );
                    if (oppositeIndex > -1) {
                        selectedLines.splice(oppositeIndex, 1);
                    }
                }
            } else {
                // Selecting - check for conflicting Over/Under from different bookmaker or line
                if (outcome === 'Over' || outcome === 'Under') {
                    const existingOverUnder = selectedLines.find(l =>
                        l.player === player &&
                        l.market === market &&
                        (l.outcome === 'Over' || l.outcome === 'Under')
                    );

                    if (existingOverUnder) {
                        // Check if it's from a different bookmaker or line
                        if (existingOverUnder.bookmaker !== bookmaker || existingOverUnder.line !== line) {
                            alert(`You already selected ${existingOverUnder.outcome} ${existingOverUnder.line} from ${existingOverUnder.bookmaker} for ${player} - ${market}.\n\nYou can only select Over/Under from the same bookmaker with the same line.\n\nPlease deselect the existing line first.`);
                            return;
                        }
                    }

                    // Add this selection
                    selectedLines.push({
                        id: lineId,
                        player,
                        market,
                        bookmaker,
                        line,
                        outcome,
                        price,
                        team
                    });

                    // Automatically select the matching opposite side (Over/Under pair)
                    const oppositeOutcome = outcome === 'Over' ? 'Under' : 'Over';
                    const oppositeLineId = `${player}|${getMarketKey(market)}|${getBookmakerKey(bookmaker)}|${line}|${oppositeOutcome}`;

                    // Check if opposite isn't already selected
                    if (!selectedLines.some(l => l.id === oppositeLineId)) {
                        // Find the opposite outcome data from the current game data
                        const oppositeData = findOppositeOutcome(player, market, bookmaker, line, oppositeOutcome);
                        if (oppositeData) {
                            selectedLines.push({
                                id: oppositeLineId,
                                player,
                                market,
                                bookmaker,
                                line,
                                outcome: oppositeOutcome,
                                price: oppositeData.price,
                                team
                            });
                        }
                    }
                } else {
                    // Not Over/Under, just add normally
                    selectedLines.push({
                        id: lineId,
                        player,
                        market,
                        bookmaker,
                        line,
                        outcome,
                        price,
                        team
                    });
                }
            }

            updateSelectionPanel();
            renderOddsComparison();
        }

        function getMarketKey(marketName) {
            // Convert market display name back to key
            for (const [key, value] of Object.entries(marketsMap)) {
                if (value === marketName) return key;
            }
            return marketName;
        }

        function getBookmakerKey(bookmakerTitle) {
            // Find bookmaker key from title
            const bookie = currentFullGameData.bookmakers.find(b => b.title === bookmakerTitle);
            return bookie ? bookie.key : bookmakerTitle;
        }

        function findOppositeOutcome(player, market, bookmaker, line, oppositeOutcome) {
            const marketKey = getMarketKey(market);
            const bookmakers = currentFullGameData.bookmakers;

            for (const bookie of bookmakers) {
                if (bookie.title !== bookmaker) continue;

                const marketData = bookie.markets.find(m => m.key === marketKey);
                if (marketData) {
                    for (const outcome of marketData.outcomes) {
                        if (outcome.description === player &&
                            outcome.name === oppositeOutcome &&
                            outcome.point == line) {
                            return {
                                price: outcome.price
                            };
                        }
                    }
                }
            }
            return null;
        }

        function addAllPlayerLines(playerName, marketKey) {
            const bookmakers = currentFullGameData.bookmakers;
            const marketName = marketsMap[marketKey] || marketKey;
            const team = findPlayerTeam(playerName);
            let addedCount = 0;

            // Check if there's already an Over/Under selected for this player + market
            const existingOverUnder = selectedLines.find(l =>
                l.player === playerName &&
                l.market === marketName &&
                (l.outcome === 'Over' || l.outcome === 'Under')
            );

            if (existingOverUnder) {
                alert(`You already have ${existingOverUnder.outcome} ${existingOverUnder.line} from ${existingOverUnder.bookmaker} selected for ${playerName} - ${marketName}.\n\nClear your existing selection first to add all lines from different bookmakers.`);
                return;
            }

            // Track processed Over/Under pairs to avoid duplicates
            const processedPairs = new Set();

            bookmakers.forEach(bookie => {
                const market = bookie.markets.find(m => m.key === marketKey);
                if (market) {
                    // Group outcomes by line for Over/Under pairing
                    const outcomesByLine = {};

                    market.outcomes.forEach(outcome => {
                        if (outcome.description === playerName) {
                            const line = outcome.point || 'N/A';
                            if (!outcomesByLine[line]) {
                                outcomesByLine[line] = {};
                            }
                            outcomesByLine[line][outcome.name] = outcome;
                        }
                    });

                    // Add complete pairs or individual outcomes
                    for (const line in outcomesByLine) {
                        const outcomes = outcomesByLine[line];
                        const pairKey = `${bookie.key}|${line}`;

                        // Skip if already processed
                        if (processedPairs.has(pairKey)) continue;

                        // Check if Over/Under market
                        if (outcomes['Over'] || outcomes['Under']) {
                            // Add both Over and Under if available
                            if (outcomes['Over']) {
                                const lineId = `${playerName}|${marketKey}|${bookie.key}|${line}|Over`;
                                if (!selectedLines.some(l => l.id === lineId)) {
                                    selectedLines.push({
                                        id: lineId,
                                        player: playerName,
                                        market: marketName,
                                        bookmaker: bookie.title,
                                        line,
                                        outcome: 'Over',
                                        price: outcomes['Over'].price,
                                        team
                                    });
                                    addedCount++;
                                }
                            }
                            if (outcomes['Under']) {
                                const lineId = `${playerName}|${marketKey}|${bookie.key}|${line}|Under`;
                                if (!selectedLines.some(l => l.id === lineId)) {
                                    selectedLines.push({
                                        id: lineId,
                                        player: playerName,
                                        market: marketName,
                                        bookmaker: bookie.title,
                                        line,
                                        outcome: 'Under',
                                        price: outcomes['Under'].price,
                                        team
                                    });
                                    addedCount++;
                                }
                            }
                            processedPairs.add(pairKey);
                        } else {
                            // Yes/No market - add all outcomes
                            for (const outcomeName in outcomes) {
                                const outcome = outcomes[outcomeName];
                                const lineId = `${playerName}|${marketKey}|${bookie.key}|${line}|${outcomeName}`;
                                if (!selectedLines.some(l => l.id === lineId)) {
                                    selectedLines.push({
                                        id: lineId,
                                        player: playerName,
                                        market: marketName,
                                        bookmaker: bookie.title,
                                        line,
                                        outcome: outcomeName,
                                        price: outcome.price,
                                        team
                                    });
                                    addedCount++;
                                }
                            }
                        }
                    }
                }
            });

            if (addedCount > 0) {
                updateSelectionPanel();
                renderOddsComparison();
            }
        }

        function updateSelectionPanel() {
            selectionCount.textContent = selectedLines.length;

            if (selectedLines.length === 0) {
                selectionPanel.classList.add('hidden');
                selectedLinesList.innerHTML = '';
                return;
            }

            selectionPanel.classList.remove('hidden');

            selectedLinesList.innerHTML = selectedLines.map((line, index) => `
                <div class="flex items-center justify-between p-3 bg-white bg-opacity-70 rounded-lg text-sm">
                    <div class="flex-1">
                        <div class="font-semibold text-gray-900">${line.player} - ${line.market}</div>
                        <div class="text-xs text-gray-600 mt-1">
                            ${line.outcome} ${line.line !== 'N/A' ? line.line : ''} @ ${line.price} (${line.bookmaker})
                        </div>
                    </div>
                    <button onclick="removeSelectedLine(${index})" class="ml-3 text-red-500 hover:text-red-700 font-bold">
                        ‚úï
                    </button>
                </div>
            `).join('');
        }

        function removeSelectedLine(index) {
            selectedLines.splice(index, 1);
            updateSelectionPanel();
            renderOddsComparison();
        }

        clearSelectionsBtn.addEventListener('click', () => {
            if (confirm('Clear all selected lines?')) {
                selectedLines = [];
                updateSelectionPanel();
                renderOddsComparison();
            }
        });

        exportSelectionsBtn.addEventListener('click', () => {
            if (selectedLines.length === 0) {
                alert('No lines selected. Please select some lines first.');
                return;
            }

            // Populate team dropdown
            csvTeamSelect.innerHTML = `
                <option value="">-- Select Team --</option>
                <option value="${currentAwayTeam}">${currentAwayTeam}</option>
                <option value="${currentHomeTeam}">${currentHomeTeam}</option>
            `;

            csvTeamModal.classList.remove('hidden');
        });

        cancelCsvExportBtn.addEventListener('click', () => {
            csvTeamModal.classList.add('hidden');
        });

        confirmCsvExportBtn.addEventListener('click', () => {
            const selectedTeam = csvTeamSelect.value;

            if (!selectedTeam) {
                alert('Please select a team for the LEAGUE_NAME.');
                return;
            }

            exportToCsv(selectedTeam);
            csvTeamModal.classList.add('hidden');
        });

        function exportToCsv(leagueTeam) {
            const kickoffDate = new Date(currentEventCommenceTime);
            const day = String(kickoffDate.getDate()).padStart(2, '0');
            const month = String(kickoffDate.getMonth() + 1).padStart(2, '0');
            const year = kickoffDate.getFullYear();
            const dateStr = `${day}.${month}.${year}`;
            const timeStr = kickoffDate.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

            let csvRows = [];
            const headers = ['Datum', 'Vreme', 'Sifra', 'Domacin', 'Gost', '1', 'X', '2', 'GR', 'U', 'O', 'Yes', 'No'];
            csvRows.push(headers);
            csvRows.push(['MATCH_NAME:NBA Player Props']);
            csvRows.push([`LEAGUE_NAME:${leagueTeam} NBA Specijal`]);

            // Group lines by player + market + bookmaker + line to combine Over/Under pairs
            const groupedLines = {};
            const processedIndices = new Set();

            selectedLines.forEach((line, index) => {
                if (processedIndices.has(index)) return;

                const key = `${line.player}|${line.market}|${line.bookmaker}|${line.line}`;

                if (!groupedLines[key]) {
                    groupedLines[key] = {
                        player: line.player,
                        market: line.market,
                        bookmaker: line.bookmaker,
                        line: line.line,
                        team: line.team,
                        over: null,
                        under: null,
                        yes: null,
                        no: null
                    };
                }

                // Add this outcome to the group
                if (line.outcome === 'Over') {
                    groupedLines[key].over = line.price;
                } else if (line.outcome === 'Under') {
                    groupedLines[key].under = line.price;
                } else if (line.outcome === 'Yes') {
                    groupedLines[key].yes = line.price;
                } else if (line.outcome === 'No') {
                    groupedLines[key].no = line.price;
                }

                processedIndices.add(index);
            });

            // Create CSV rows from grouped data
            for (const key in groupedLines) {
                const group = groupedLines[key];
                const row = Array(13).fill('');
                row[0] = dateStr;
                row[1] = timeStr;
                row[3] = group.player;
                row[4] = `Total ${group.market}`;

                if (group.over !== null || group.under !== null) {
                    // Over/Under market
                    row[8] = group.line;
                    row[9] = group.under || '';
                    row[10] = group.over || '';
                } else if (group.yes !== null) {
                    // Yes/No market
                    row[11] = group.yes || '';
                    row[12] = group.no || '';
                }

                csvRows.push(row);
            }

            let csvContent = "data:text/csv;charset=utf-8," + csvRows.map(e => e.join(",")).join("\r\n");
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `${leagueTeam}_nba_odds_comparison.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

    </script>
</body>
</html>
